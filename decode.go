package byte64

import (
	"bytes"
)

// -0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
const decodeChars = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a" + // 0123456789
	"\x00\x00\x00\x00\x00\x00\x00" +
	"\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24" + // ABCDEFGHIJKLMNOPQRSTUVWXYZ
	"\x00\x00\x00\x00" +
	"\x25" + // _
	"\x00" +
	"\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f" + // abcdefghijklmnopqrstuvwxyz
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

// Decode function
func Decode(s string) []byte {
	buf := bytes.Buffer{}
	b := make([]byte, 4)
	size := 0
	for i := 0; i < len(s); i++ {
		b[size] = s[i]
		size++
		if size == 4 {
			//
			c0 := decodeChars[b[0]]
			c1 := decodeChars[b[1]]
			c2 := decodeChars[b[2]]
			c3 := decodeChars[b[3]]

			buf.WriteByte(c1<<6 + c0)    // B0
			buf.WriteByte(c2<<4 + c1>>2) // B1
			buf.WriteByte(c3<<2 + c2>>4) // B2

			size = 0
		}
	}

	if size == 2 {
		c0 := decodeChars[b[0]]
		c1 := decodeChars[b[1]]

		buf.WriteByte(c1<<6 + c0) // B0
	}

	if size == 3 {
		c0 := decodeChars[b[0]]
		c1 := decodeChars[b[1]]
		c2 := decodeChars[b[2]]

		buf.WriteByte(c1<<6 + c0)    // B0
		buf.WriteByte(c2<<4 + c1>>2) // B1
	}

	return buf.Bytes()
}
